#!/usr/bin/make -rRf

# ntLink: Scaffold assemblies using long reads
# Written by Lauren Coombe @lcoombe
# ntLink v0.0.1

# Input files
target=None
reads=None
min_ref_targets=$(addsuffix .k$(k).w$(w).tsv, $(reads))
fai_ref_targets=$(addsuffix .fai, $(reads))
bf_ref_targets=$(addsuffix .k$(k).z$(z).bf, $(reads))

# Path to pairing code
ntlink_path=$(shell dirname $(realpath $(MAKEFILE_LIST)))

# Window size
w=1000

# Kmer size
k=32

# Number of threads
t=4

# Minimum contig size
z=500

# Use solid Bloom filter?
solid=False

# Size of Bloom filters to construct
bloom_size=1G

# Number of threads for ntjoin_assemble.py (Change with caution -- multi-processing increases memory)
assemble_t=1

# Minimum edge weight
n=2

# Minimum gap size between scaffolds
g=20

# Minimum # anchoring ONT reads for an edge
a=1

# Maximum number of contigs in a run for full transitive edge addition
m=10

# Prefix for output files
prefix=out.k$(k).w$(w).n$(n).z$(z)

SHELL=bash -e -o pipefail
ifeq ($(shell zsh -e -o pipefail -c 'true' 2>/dev/null; echo $$?), 0)
# Set pipefail to ensure that all commands of a pipe succeed.
SHELL=zsh -e -o pipefail
# Report run time and memory usage with zsh.
export REPORTTIME=1
export TIMEFMT=time user=%U system=%S elapsed=%E cpu=%P memory=%M job=%J
endif

# Record run time and memory usage in a file using GNU time
ifneq ($(shell command -v gtime),)
time=command gtime -v -o $@.time
else
time=command time -v -o $@.time
endif

# Compress in parallel
ifneq ($(shell command -v pigz),)
gzip=pigz -p$t -f
else
gzip=gzip -f
endif

help:
	@echo ""
	@echo "ntLink: Scaffolding assemblies using long reads"
	@echo "ntLink v0.0.1"
	@echo "Usage: ntLink scaffold target=<target scaffolds> reads='List of long read files'"
	@echo ""
	@echo "Options:"
	@echo "target			Target assembly to be scaffolded in fasta format"
	@echo "reads		List of long read files (separated by a space)"
	@echo "prefix			Prefix of intermediate output files [out.k<k>.w<w>.n<n>]"
	@echo "t			Number of threads [4]"
	@echo "k			K-mer size for minimizers [32]"
	@echo "w			Window size for minimizers (bp) [1000]"
	@echo "n			Minimum graph edge weight [1]"
	@echo "g			Minimum gap size (bp) [20]"
	@echo "m			Maximum number of contigs in a run for full transitive edge addition [10]"
	@echo "bloom_size   Size of Bloom filter [1G]"
	@echo "a            Minimum number of anchored ONT reads required for an edge [1]"
	@echo "solid        If True, use solid BF [False]"
	@echo "z			Minimum size of contig (bp) to scaffold [1000]"
	@echo ""
	@echo "Note: "
	@echo "	- Ensure all assembly and read files are in the current working directory, making soft links if neccessary"
	@echo ""

ntJoin_scaffold: check_params \
	$(min_ref_targets) \
	$(target).k$(k).w$(w).tsv \
	$(target).fai \
	$(target).k$(k).w$(w).n$(n).z$(z).assigned.scaffolds.fa \
	$(target).k$(k).w$(w).n$(n).z$(z).ntJoin.scaffolds.fa

scaffold: ntJoin_graph \
	abyss_scaffold

ntJoin_graph: check_params \
	$(min_ref_targets) \
	$(target).k$(k).w$(w).tsv \
	$(target).fai \
	$(prefix).scaffold.dot \
	$(prefix).tigpair_checkpoint.tsv

links_scaffold: $(prefix).tigpair_checkpoint.tsv \
	quast_$(target).k$(k).w$(w).n$(n).z$(z).links.fa

abyss_scaffold: $(prefix).scaffold.dot \
	$(target).k$(k).w$(w).n$(n).z$(z).abyss-scaffold.fa

all_scaffolders: $(target).k$(k).w$(w).n$(n).z$(z).abyss-scaffold.fa \
	$(target).k$(k).w$(w).n$(n).z$(z).links.fa \
	$(target).k$(k).w$(w).n$(n).z$(z).ntJoin.scaffolds.fa

compare_scaffolders_analysis: $(prefix).abyssfac.tsv \
	quast_$(target).k$(k).w$(w).n$(n).z$(z).abyss-scaffold.fa \
	quast_$(target).k$(k).w$(w).n$(n).z$(z).links.fa \
	quast_$(target).k$(k).w$(w).n$(n).z$(z).all.scaffolds.fa

check_params:
ifeq ($(reads), None)
	$(error ERROR: Must set reads)
endif
ifeq ($(target), None)
	$(error ERROR: Must set target)
endif


version:
	@echo "ntLink v0.0.1"
	@echo "Written by Lauren Coombe (lcoombe@bcgsc.ca)"

clean:
	rm $(target).k$(k).w$(w).tsv $(reads).k$(k).w$(w).tsv

.PHONY: help scaffold version long check_params clean
.DELETE_ON_ERROR:
.SECONDARY:

%.k$(k).z$(z).bf: %
	cat $< |seqtk seq -L$(z) |$(time) abyss-bloom build -v -k $(k) -b $(bloom_size) -t rolling-hash -j $(t) $@ -

out.k$(k).z$(z).solid.bf: $(target).k$(k).z$(z).bf $(bf_ref_targets)
	$(time) abyss-bloom intersect -v -k $(k) $@ $^

ifeq ($(solid), True)
%.k$(k).w$(w).tsv: % out.k$(k).z$(z).solid.bf
	$(time) $(ntlink_path)/src/indexlr --pos --strand -k $(k) -w $(w) -t $(t) -s out.k$(k).z$(z).solid.bf $< > $@
else
%.k$(k).w$(w).tsv: %
	$(time) $(ntlink_path)/src/indexlr --pos --strand -k $(k) -w $(w) -t $(t) $< > $@
endif

%.fai: %
	$(time) samtools faidx $<

%.fa.gz: %.fa
	$(time) $(gzip) $<

$(prefix).scaffold.dot: $(target).k$(k).w$(w).tsv $(min_ref_targets)
	$(time) $(ntlink_path)/bin/ntjoin_long_pair.py -p $(prefix) -n $(n) -s $<  \
	-k $(k) -a $(a) -z $(z) $(min_ref_targets)

$(prefix).tigpair_checkpoint.tsv: $(prefix).scaffold.dot
	touch $@

$(target).k$(k).w$(w).n$(n).z$(z).assigned.scaffolds.fa: $(prefix).scaffold.dot $(target)
ifeq ($(agp), True)
	$(time) $(ntlink_path)/bin/ntjoin_long_scaffold.py -p $(prefix) \
	-z $(z) -g $(g) -n $(n) -t $(assemble_t)  --agp -k $(k) -w $(w) -d $< $(target)
else
	$(time) $(ntlink_path)/bin/ntjoin_long_scaffold.py -p $(prefix) \
	-z $(z) -g $(g) -n $(n) -t $(assemble_t) -k $(k) -w $(w) -d $< $(target)
endif

$(target).k$(k).w$(w).n$(n).z$(z).ntJoin.scaffolds.fa: $(target).k$(k).w$(w).n$(n).z$(z).all.scaffolds.fa
	ln -sf $< $@


$(target).k$(k).w$(w).n$(n).z$(z).unassigned.scaffolds.fa: $(target).k$(k).w$(w).n$(n).z$(z).assigned.scaffolds.fa
	touch $@

%.all.scaffolds.fa: %.assigned.scaffolds.fa %.unassigned.scaffolds.fa
	$(time) cat $^ > $@

# Run abyss-scaffolding layout

# Run abyss-scaffold scaffolding layout
$(prefix).abyss-scaffold.path: $(prefix).scaffold.dot
	$(time) abyss-scaffold -k2 -n$(n)-20 -s$(z) --min-gap $(g) -g $(prefix).scaffold.abyss-scaffold.dot $(target) $< > $@

$(target).k$(k).w$(w).n$(n).z$(z).abyss-scaffold.fa: $(prefix).abyss-scaffold.path
	$(time) MergeContigs -k2 $(target) $< > $@

# Run LINKS scaffolding layout
$(target).k$(k).w$(w).n$(n).z$(z).links.fa: $(target).k$(k).w$(w).n$(n).z$(z).assigned.scaffolds.fa
	touch empty.fof
	$(time) LINKS -f $(target) -s empty.fof -b $(prefix) -z $(z) -l $(n)
	ln -s $(prefix).scaffolds.fa $@

# abyss-fac stats
$(prefix).abyssfac.tsv: $(target).k$(k).w$(w).n$(n).z$(z).all.scaffolds.fa $(target).k$(k).w$(w).n$(n).z$(z).abyss-scaffold.fa $(target).k$(k).w$(w).n$(n).z$(z).links.fa
	abyss-fac $^ > $@

# Quast
# Set reference
ref=None
quast_%: %
	quast -t 24 -o quast_$* -r $(ref) --fast --scaffold-gap-max-size 100000 --split-scaffolds \
		$*
